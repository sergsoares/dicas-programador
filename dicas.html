<ol>
  <li><strong>Se preocupe com o que constrói</strong> - Por que se gastar sua vida desenvolvendo software se você não se preocupa com ele ser bom?</li>
  <li><strong>Pense! Sobre o seu trabalho</strong> - Desligue o piloto automático e tome o controle. Constantemente critique e avalie o seu trabalho.</li>
  <li><strong>Dê opções, não crie desculpas</strong> - Ao invés de dar desculpas, dê opções. Não diga que não pode ser feito; explique como <em>pode</em> ser feito.</li>
  <li><strong>Não conviva com janelas quebradas</strong> - Corrija designs ruins, decisões erradas e código ruim quando vê-los.</li>
  <li><strong>Seja um catalisador de mudanças</strong> - Você não pode forçar as pessoas a mudarem. Mas você pode mostrá-las como o futuro pode ser e ajudá-las a participar na criação disso.</li>
  <li><strong>Veja o quadro geral</strong> - Não fique tão focado só nos detalhes que esqueça de verificar o que está acontecendo ao se redor.</li>
  <li><strong>Faça da Qualidade um requisito</strong> - Envolva os usuários para determinar a real qualidade que o projeto precisa ter e cumpra.</li>
  <li><strong>Invista regularmente no seu Portfolio de Conhecimento</strong> - Faça do aprender um hábito.</li>
  <li><strong>Analise criticamente o que você lê ou escuta</strong> - Não seja influenciado pelo hype das coisas. Analise a informação em termos de você e seu projeto.</li>
  <li><strong>É o que você diz e a maneira que você diz</strong> - Não faz sentido você ter grandes ideias se você não consegue comunicá-las efetivamente.</li>
  <li><strong>DRY - Don’t Repeat Yourself (Não se repita)</strong> - Cada pedaço de código deve ser único e o mais genérico possível.</li>
  <li><strong>Faça ser fácil de reutilizar</strong> - Se é fácil de reutilizar, pessoas vão reutilizar. Crie um ambiente que suporte o reuso.</li>
  <li><strong>Elimine os efeitos colaterais entre coisas não relacionadas</strong> - Crie componentes que sejam auto-contidos, independentes e tenham um único e bem definido propósito.</li>
  <li><strong>Não existem decisões finais</strong> - Nenhuma decisão é escrita em pedra. Ao invés disso, pense que as decisões são escritas em areia de praia, e se planeje para ir sempre mudando e adaptando.</li>
  <li><strong>Use “tracer bullets” para achar o alvo</strong> - Faça as coisas e as deixe serem vistas, assim você pode ver o quanto elas chegam do que seu cliente realmente deseja.</li>
  <li><strong>Faça protótipos para aprender</strong> - Prototipar é uma experiência de aprendizado. O seu valor não está no código em que você produz, mas nas lições que aprendeu para montar.</li>
  <li><strong>Programe perto do problema</strong> - Crie e codifique na linguagem do seu usuário, como se você fosse ele.</li>
  <li><strong>Estime para evitar surpresas</strong> - Estime antes de começar. Você irá possivelmente ver problemas a frente e conseguirá se organizar melhor.</li>
  <li><strong>Itere o tempo com o código</strong> - Use a experiência que você ganha construindo a aplicação para refinar a escala de tempo do projeto e ter melhores estimativas.</li>
  <li><strong>Escreva e Rabisque</strong> - Textos e rabiscos nunca se tornam obsoletos. Eles ajudam a melhorar o seu trabalho e simplificar depurações e testes.</li>
  <li><strong>Use o poder da linha de comando</strong> - Use linha de comando quando interfaces não são necessárias.</li>
  <li><strong>Use um bom editor</strong> - O editor precisa ser uma extensão da sua mão, tenha certeza que seu editor é configurável, extensível e vocês trabalham bem juntos.</li>
  <li><strong>Sempre use versionamento de código</strong> - Versionamento de código são como máquinas do tempo para o seu trabalho, aqui é possível voltar atrás!</li>
  <li><strong>Corrija o problema. Não fique culpando</strong> - Não importa se o bug é sua culpa ou de outro, é um problema e precisa ser corrigido.</li>
  <li><strong>Não entre em pânico quando estiver debugando</strong> - Respire bem fundo e <em>pense!</em> sobre o que pode estar causando o bug.</li>
  <li><strong>O “select” não está quebrado</strong> - É muito raro achar um problema que seja de fato do sistema operacional ou do compilador. O bug na maioria das vezes está na sua aplicação.</li>
  <li><strong>Não presuma, prove!</strong> - Prove suas premissas num ambiente com dado real e sob as mesmas condições.</li>
  <li><strong>Aprenda manipulação de texto na sua linguagem</strong> - você passa boa parte do tempo trabalhando com textos. Por que não deixar o computador fazer um pouco desse trabalho para você?</li>
  <li><strong>Escreva código que faça código</strong> - Geradores de código aumentam sua produtividade e ajudam a evitar duplicações.</li>
  <li><strong>Você não pode escrever um software perfeito</strong> - Softwares não podem ser perfeitos. Proteja seu código e os usuários dos erros inevitáveis.</li>
  <li><strong>Faça o Design com contratos</strong> - Use contratos para documentar e verificar se o código faz o que se é pedido.</li>
  <li><strong>Quebre cedo</strong> - Um programa morto normalmente dá menos problemas que um programa deficiente.</li>
  <li><strong>Use <em>assertions</em> para previnir o impossível</strong> - use assertions para validar suas premisas. E use para proteger seu código de incertezas.</li>
  <li><strong>Use <em>exceptions</em> para problemas excepcionais</strong> - Exceptions podem prejudicar a leitura e manutenibilidade do projeto, criando os famosos código spaguetti. Reserve <em>exeptions</em> para coisas de fato excepcionais.</li>
  <li><strong>Termine o que você começou</strong> - Quando possível, a rotina ou objeto responsável por alocar aquele recurso, precisa ser responsável por desalocar também.</li>
  <li><strong>Minimize o acoplamento entre os módulos</strong> - Evite o acoplamento aplicando a <a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Lei de Demeter</a>.</li>
  <li><strong>Configure, não integre</strong> - implemente escolhas de tecnologia para uma aplicação como se opções de configuração, não somente como processo de integração ou código agregado.</li>
  <li><strong>Coloque abstrações no código, detalhes no metadata</strong> - Codifique para o caso geral e coloque os casos específicos de forma separada do código base.</li>
  <li><strong>Analise o Workflow para melhorar a concorrência</strong> - busque formas de realizar código em concorrência no workflow de seu usuário.</li>
  <li><strong>Desenvolva usando serviços</strong> - Codifique em termos de serviços, independentes, bem definidos e com interfaces consistentes.</li>
  <li><strong>Separe as Views das Models</strong> - Para ganhar flexibilidade a baixo custo, desenvolva sua aplicação em termos de models e views.</li>
  <li><strong>Não programe por coincidência</strong> - Confie em coisas confiáveis. Tome cuidado com a complexidade acidental e não confunda uma feliz coincidência com o plano final.</li>
  <li><strong>Estime a ordem de seus algoritmos</strong> - Tenha uma ideia de o quão demoradas as coisas podem acontecer antes de escrever seu código.</li>
  <li><strong>Teste suas estimativas</strong> - Análises matemáticas de algoritmos não dizem tudo. Teste seu código sempre no ambiente mais próximo do real.</li>
  <li><strong>Refatore cedo, refatore frequentemente</strong> - Assim como você pode arrumar e reorganizar um jardim, reescreva, retrabalhe e rearquitete seu código sempre que necessário. Corrija a raiz dos problemas.</li>
  <li><strong>Codifique para testar</strong> - Comece pensando sobre como testar antes de escrever uma linha de código.</li>
  <li><strong>Teste seu software, ou seus usuários irão testar por você</strong> - Teste implacavelmente. Não deixe seus usuários acharem bugs para você.</li>
  <li><strong>Não use código mágico que você não entende</strong> - Mágicas podem gerar códigos complicados. Tenha certeza que você entende tudo que o código faz, antes de implementá-lo em seu projeto.</li>
  <li><strong>Não pegue requisitos - cave até eles</strong> - Os requisitos raramente estão só na superfície. Eles estão enterrados em camadas de premissas, equívocos e política. Veja além do que foi pedido.</li>
  <li><strong>Trabalhe com o usuário para pensar como o usuário</strong> - Teste com o usuário, é a única maneira de saber como ele de fato será usado. Pegue todos os insights possíveis assim.</li>
  <li><strong>Abstrações vivem mais que detalhes</strong> - Invista em abstrações, não na implementação. Abstrações podem sobreviver as mudanças de diferentes implementações e tecnologias.</li>
  <li><strong>Cria um Glossário do projeto</strong> - Crie e mantenha um lugar com todos os termos e vocabulários do projeto, pessoas novas podem não saber certas definições do projeto.</li>
  <li><strong>Não pense fora da caixa, ache a caixa!</strong> - Ao enfrentar com problemas impossíveis. Pergunte a si mesmo: “Isso precisa ser feito dessa maneira? Isso realmente precisa existir?”.</li>
  <li><strong>Comece quando você estiver pronto</strong> - Você tem adquirido experiência com o tempo, não ignore as dúvidas que tiver.</li>
  <li><strong>Algumas coisas são melhor quando feitas do que descritas</strong> - Não caia numa espiral de criar especificações e pensamentos, uma hora você precisa começar a codificar.</li>
  <li><strong>Não seja um escravo de métodos formais</strong> - Não adote cegamente uma técnica sem colocar no contexto do seu desenvolvimento e suas capacidades.</li>
  <li><strong>Ferramentas caras não produzem designs melhores</strong> - Tome cuidado com o hype das ferramentas, dogmas da indústria e custos. Julgue suas ferramentas pelos seus méritos.</li>
  <li><strong>Organize equipes por funcionalidades</strong> - Não separe designers de desenvolvedores, monte equipes da mesma forma que você cria o código.</li>
  <li><strong>Teste cedo, teste frequentemente, teste automaticamente</strong> - Testes que rodam a cada build são muito mais efetivos que testes esporádicos.</li>
  <li><strong>O código não está pronto até que os testes rodem</strong> - só isso.</li>
  <li><strong>Use sabotadores para testar seu teste</strong> - Introduza bugs de propósito em partes separadas do código somente para verificar se os seus testes vão pegar.</li>
  <li><strong>Teste o estado de cobertura, não a cobertura do teste</strong> - Identifique e teste os diferentes estados do código. Testar só linhas de código não é o suficiente.</li>
  <li><strong>Ache bugs uma única vez</strong> - Uma vez que um humano encontrou um bug, essa deverá ser a última vez que ele irá achá-lo. Crie testes para sempre verificar o bug.</li>
  <li><strong>Inglês é uma outra linguagem de programação</strong> - Escreva documentos como você escreve código, honre o princípio do <em>DRY</em>, use metadata e geração automática.</li>
  <li><strong>Assine o seu trabalho</strong> - os grandes construtores ficam orgulhosos de assinar suas obras, você também deveria se orgulhar.</li>
</ol>
